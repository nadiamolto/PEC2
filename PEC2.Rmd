---
title: "Untitled"
output: word_document
---

```{r}
library("pheatmap")
library("RColorBrewer")
require("dplyr")
library("Biobase")
require("DESeq2")
library("apeglm")
library("pheatmap")
library("genefilter")
require("ggplot2")
library("limma")
```

```{r}
setwd("C:/Users/al153/Desktop/PEC2")
#Leemos los archivos y los pasamos a dataframe. Por un lado tenemos targets que nos identifica las muestras tomadas
#nos da datos sobre ellas y sobre las personas a las que les fueron extraidas y del experimento llevado a cabo
#En el documento counts tenemos el conteo de los resultados del RNA-seq en cuanto a expresion, es decir,
#el numero de lecturas asignadas a cada muestra para cada gen de ENSEMBL
targets<-read.csv("targets.csv",header=TRUE) #Importamos datos targets
counts<-read.csv("counts.csv",header = TRUE, sep=";") #Importamos datos counts
```

```{r}
#Tenemos que generar un subset de targets que tenga 10 muestras aleatorias de cada grupo

#Aunque es probable que exista una funcion mucho mas rapida sin hacer tantos pasos, lo primero que hago va a sercrear tres subsets en forma de tabla y que cada uno contenga el grupo que me interesa
NIT<-filter(targets,Group=="NIT")
ELI<-filter(targets,Group=="ELI")
SFI<-filter(targets,Group=="SFI")

#Ahora genero una muestra aleatoria de cada uno de ellos con 10 valores
muestreo1 <- sample_n(NIT, size= 10)
muestreo2<-sample_n(ELI,size=10)
muestreo3<-sample_n(SFI,size=10)

#Ahora uno los 3 muestreos en una misma tabla
targets30<-rbind(muestreo1,muestreo2,muestreo3)

#Para aleatorizar el orden de las filas ordeno por nombre de la muestra, que es al azar.
targets30<-arrange(targets30,Sample_Name)

rownames(targets30)<-targets30$Sample_Name

#Ahora para las muestras que tenemos, hay que sacar la informacion de la variable counts o sea, crear una matriz con unicamente las muestras que se han elegido junto con el conteo de las mismas frente a los genes.

counts$X<-gsub("\\..*", "", counts$X, fixed = FALSE) #Eliminamos el . seguido del numero que indica la version de ENSEMBL y que no sirve para la anotacion

samples<-targets30$Sample_Name #Seleccionamos el nombre de las muestras
countsample<-counts[,samples] #Filtramos en counts unicamente las muestras seleccionadas
rownames(countsample)<-counts$X
#Es importante que el orden de las columnas del conteo y de las muestras de targets30 esten en el mismo orden para que se interprete correctamente

all(rownames(targets30$Sample_Name)==colnames(countsample))

#Para empezar con el analisis vamos a emplear DESeq2 de bioconductor (https://link.springer.com/article/10.1186/s13059-014-0550-8)suponiendo que estos datos no han sido normalizados

#Construimos el objeto o dataset en el formato que DESeq emplea a partir de la matriz de conteo y la matriz con informacion sobre el experimento. Queremos analizar la expresion diferencial entre tipos de infiltracion, de ahi que empleemos la variable diseño group.

colsample <- targets30
dds <- DESeqDataSetFromMatrix(countData = countsample,
                                  colData = targets30,
                                  design = ~ Group)
dds

```

```{r}
#Puesto que en el conteo hay numerosas muestras que no contienen genes y por tanto el conteo se reduce a cero, podemos hacer un filtrado eliminando aquellas celdas que no sumen al conteo. Podriamos eleiminar aquellas con un numero redicido pero estariamos sesgando los resultados. Esto ocurre porque los datos no son homoce
nrow(dds)
dds <- dds[ rowSums(counts(dds)) >=1, ]
nrow(dds)

```

```{r}
#Vemos como se ha reducido el numero de columnas del objeto como resultado de la eliminacion de aquellos conteos que fueran inferiores a 1.

#Ahora seria conveniente ver la representacion de los grupos de datos que tenemos, esto se puede hacer con una PCA. Sin embargo, es probable que si la realizamos con los datos de los que disponemos, algunas caracteristicas de los valores con mayor conteo enmascaren aquellos que tienen menor. Por ello, la mejor opcion es calcular los logaritmos de los valores normalizando previamente y una pseudocuenta, de la cual dependerá la contribución de los valores de conteo mas bajos. Emplearemos VST,que calcula una transformacion estabilizadora de la varianza produciendo una matriz de valores mas o menos homeostacicos.

vsd <- vst(dds, blind = FALSE)

#una vez ajustados los datos, vamos a ver la distancia entre muestras de forma que nos de una idea de si se ajusta a la idea inicial del experimento.

plotPCA(vsd, intgroup = ("Group"))

```

```{r}
##EL PCA no resulta concluyente, no hay un comportamiento claro de las muestras, por ello, se puede recurrir a un GLM-PCA
library("glmpca")
gpca <- glmpca(counts(dds), L=2)
gpca.dat <- gpca$factors
gpca.dat$Group <- dds$Group

ggplot(gpca.dat, aes(x = dim1, y = dim2, color = Group, shape = Group)) +
  geom_point(size =3) + coord_fixed() + ggtitle("glmpca - Generalized PCA")

```




```{r}
 #se emplea el método DESeq que aportara un ajuste de los datos que tenemos. Este método lo que hace es (?DESeq) y devuelve un dataset con los datos ajustados.
dds <- DESeq(dds)
```
```{r}
#Ahora tenemos los datos procesados con logaritmo veamos los resultados de las comparaciones entre grupos:
resultsEN<-results(dds, contrast=c("Group","ELI","NIT")) #Comparacion entre ELI y NIT
resultsES<-results(dds, contrast=c("Group", "ELI", "SFI")) #Comparacion ELI y SFI
resultsNS<-results(dds, contrast=c("Group","NIT", "SFI")) #Compraracion NIT y SFI
resultsEN
resultsES
resultsNS
```
```{r}


#Tenemos parámetros como baseMean que es el promedio de los valores del conteo normalizados y divididos por el tamaño y el resto son los contrastes realizados para los 3 grupos. Log2foldchange nos indica la estimacion del efecto de cada comparacion de una linea celular con respecto a la otra en las comparaciones 2 a 2. lfCSE seria la incertidumbre asociada a cada comparacion. 
#Los valores NA significan que todos los recuentos para ese gen fueron 0 o que el gen se excluyo del analisis.
#Podemos ver un resumen de los resultados:
summary(resultsEN)
summary(resultsES)
summary(resultsNS)
```
```{r}
#Vemos como por ejemplo entre las comparaciones ELI y SFI , así como NIT  y SFI presentan genes diferencialmente expresados, posiblemente se deba a que en el caso de SFI se expresen menos genes que en el resto. Por lo general, se esperaria que donde mayor cantidad de genes diferencialmente expresados hubiera seria en las comparaciones entre NIT y el resto, ya que son las celulas no infiltradas.

#DEbido a que no se tienen evidencias en cuanto a expresion de un tipo de infiltracion con respecto de otro, se deja el p value tal y como viene por defecto, por ejemplo del 10%. Podemos ver cuantos genes aparecen diferencilament expresados para cada comparacion.

sum(resultsEN$padj < 0.1, na.rm=TRUE)
```
```{r}
sum(resultsES$padj < 0.1, na.rm=TRUE)
```

```{r}
sum(resultsNS$padj < 0.1, na.rm=TRUE)
```


```{r}
#Estos serían el número de genes para cada comparacion que presentan un valor de expresion significativamente diferencial si consideramos un p valor por debajo de 0,1.

#Podemos ver aquellos genes que presentan una mayor expresion o una menor expresion.

#Primero para la comparacion entre ELI Y NIT:

resSig1 <- subset(resultsEN, padj < 0.1)
head(resSig1[ order(resSig1$log2FoldChange), ]) #upregulated
```



```{r}
head(resSig1[ order(resSig1$log2FoldChange, decreasing = TRUE), ]) #Downregulated

```





```{r}
#Para ELI y SFI

resSig2 <- subset(resultsES, padj < 0.1)
head(resSig2[ order(resSig2$log2FoldChange), ]) #upregulated
head(resSig2[ order(resSig2$log2FoldChange, decreasing = TRUE), ]) #Downregulated
```
```{r}
#NIT Y SFI

resSig3 <- subset(resultsNS, padj < 0.1)
head(resSig3[ order(resSig3$log2FoldChange), ])
```


```{r}
hist(resultsEN$pvalue[resultsEN$baseMean > 1], breaks = 0:20/20,
     col = "grey50", border = "white") #Diagrama de los p valores para cada una de las comparaciones:
```
```{r}
hist(resultsES$pvalue[resultsES$baseMean > 1], breaks = 0:20/20,
     col = "grey50", border = "white")
```
```{r}
hist(resultsNS$pvalue[resultsNS$baseMean > 1], breaks = 0:20/20,
     col = "grey50", border = "white") #Diagrama de los p valores para cada una de las comparaciones:
```

```{r}
#Vemos como los resultados de los valores p de la ultima comparacion aparecen numerosos valores distintos de 0 y bastante elevados, de ahi que solo aparezca un gen diferencialmente expresado.Con recuentos menores a 3 o 4 e seprobable que los resultados hubieran sido mas favorables pero hubieramos sesgado posibles positivos.
```

```{r}
#Veamos la representacion d elos valores p bajos. Los genes que presentan estos valores estan enmascarados al presentar un ruido de Poisson, con ello, no hay opcion de ver genes diferencialmente expresados para valores de p muy bajos. Veamos cuantos genes hay enmascarados por este fenomeno.
resLFC1 <- results(dds, lfcThreshold=1)
table(resLFC1$padj < 0.1)
qs <- c(0, quantile(resLFC1$baseMean[resLFC1$baseMean > 0], 0:6/6))
bins <- cut(resLFC1$baseMean, qs)
levels(bins) <- paste0("~", round(signif((qs[-1] + qs[-length(qs)])/2, 2)))
fractionSig <- tapply(resLFC1$pvalue, bins, function(p)
                          mean(p < .05, na.rm = TRUE))
barplot(fractionSig, xlab = "mean normalized count",
                     ylab = "fraction of small p values")
```
```{r}
#Los genes con recuentos muy bajos no presentan ninguna aportacion en el estudio, en este caso, hemos mantenido aquellos con un conteo igual o superior a 1, quizás seria mas conveniente mantener aquellos con conteo igual o superior a 4.
#Al eliminar los genes débilmente expresados al procedimiento FDR, podemos encontrar que más genes son significativos entre los que conservamos, y así mejoramos el poder de nuestra prueba. Hay que ir con cuidado en poner un limite de eliminacion porque podriamos estar eliminando genes que si son significativos.
```


```{r}
#Para una vision mas generalizada podemos emplear el MA plot para cada una de las muestras:
plotMA( resultsEN, ylim = c(-3, 3) )
```
```{r}
plotMA( resultsES, ylim = c(-3, 3) )
```
```{r}
plotMA( resultsNS, ylim = c(-3, 3) )
```

```{r}
#El diagrama MA representa cada gen con un punto. El eje x es la expresión promedio sobre todas las muestras, el eje y el cambio log2 veces de conteos normalizados (es decir, el promedio de conteos normalizados por factor de tamaño) entre tratamientos. Los genes con un valor p ajustado por debajo de un umbral (aquí 0.1) se muestran en rojo. 
#Hacia arriba apareceran los valores sobrerregulados y por debajo los infrarregulados.
```

```{r}
#Podemos asignar nuevos identificadores a los genes diferencialmente expresados para poder buscarlos en diferentes bases de datos
library("AnnotationDbi") #Cargamos el paquete de anotacion

library("org.Hs.eg.db") #Genoma humano
columns(org.Hs.eg.db) #Nos va a proporcionar todos los tipos de claves disponibles del genoma humano en la base de datos AnotationDbi
```
```{r}

#Vamos a ver los resultados en ENSEMBL

#Para la comparacion entre ELI y NIT
ens.str1 <- substr(rownames(resultsEN), 1, 15) #ID de los genes
resultsEN$symbol <- mapIds(org.Hs.eg.db, #Con mapIds agregamos columnas a la tabla de resultados
                     keys=ens.str1,
                     column="SYMBOL", #queremos el elemento symbol
                     keytype="ENSEMBL", #queremos los resultados en claves de ENSEMBL
                     multiVals="first")
#Lo mismo pero para la ID de Entrez, así tendremos como resultado el símbolo y la clave en ENTREZ.
resultsEN$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str1,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

#Para la comparacion entre ELI y SFI
ens.str2 <- substr(rownames(resultsES), 1, 15) #ID de los genes
resultsES$symbol <- mapIds(org.Hs.eg.db, #Con mapIds agregamos columnas a la tabla de resultados
                     keys=ens.str2,
                     column="SYMBOL", #queremos el elemento symbol
                     keytype="ENSEMBL", #queremos los resultados en claves de ENSEMBL
                     multiVals="first")
#Lo mismo pero para la ID de Entrez, así tendremos como resultado el símbolo y la clave en ENTREZ.
resultsES$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str2,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

#Para la comparacion entre NIT y SFI
ens.str3 <- substr(rownames(resultsNS), 1, 15) #ID de los genes según 
resultsNS$symbol <- mapIds(org.Hs.eg.db, #Con mapIds agregamos columnas a la tabla de resultados
                     keys=ens.str3,
                     column="SYMBOL", #queremos el elemento symbol
                     keytype="ENSEMBL", #queremos los resultados en claves de ENSEMBL
                     multiVals="first")
#Lo mismo pero para la ID de Entrez, así tendremos como resultado el símbolo y la clave en ENTREZ.
resultsNS$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str3,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

#Con esto hemos conseguido que a parte de los identificadores de los genes que aparecian en couts, tengamos tres tablas, una para cada comparación con las ID de los genes segun bases de datos externas.Por ejemplo:

#ELI Y NIT
resOrdered1 <- resultsEN[order(resultsEN$pvalue),]
head(resOrdered1) #Ejemplo de una de las tablas

#ELI Y SFI
resOrdered2 <- resultsES[order(resultsES$pvalue),]

#NIT Y SFI
resOrdered3 <- resultsNS[order(resultsNS$pvalue),]

```
```{r}
#Vemos como al final de la tabla aparecen los identificadores.

#Exportamos los resultados a archivos CSV:
resOrderedDF1 <- as.data.frame(resOrdered1)[1:100, ]
write.csv(resOrderedDF1, file = "resultsEN.csv")

resOrderedDF2 <- as.data.frame(resOrdered2)[1:100, ]
write.csv(resOrderedDF2, file = "resultsES.csv")

resOrderedDF3 <- as.data.frame(resOrdered3)[1:100, ]
write.csv(resOrderedDF3, file = "resultsNS.csv")
```

```{r}
#Para obtener resultados mas completos podemos emplear el paquete ReportingTools de bioconductor que nos redigirirá a un enlace html con los resultados.



```

```{r}
#Para comparar entre los resultados obtenidos podemos representar un diagrama de Venn para las tres muestras empleando el paquete limma con un p valor ajustado de 10%.

venn_data <- data.frame(EN = resultsEN$padj<0.1,
                        ES = resultsES$padj<0.1,
                        NS = resultsNS$padj<0.1)
library(limma)
vennDiagram(venn_data)

```


